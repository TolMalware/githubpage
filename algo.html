<link rel="stylesheet" href="main.css">
<style>
    .fig {
     text-align: center; /* Выравнивание по центру */ 
    }
   </style>
<div class = "wrapper">
    <div class="post-content" itemprop="articleBody">
<h3 id="Связный список">Связный список</h3>
<p>Основное назначение связного списка — предоставление механизма для хранения и доступа к произвольному количеству данных. Как следует из названия, это достигается связыванием данных вместе в список.
Прежде чем мы перейдем к рассмотрению связного списка, давайте вспомним, как хранятся данные в массиве.
<div><img src="data_structures_001.jpg"  alt=""></div>
Как показано на рисунке, данные в массиве хранятся в непрерывном участке памяти, разделенном на ячейки определенного размера. Доступ к данным в ячейках осуществляется по ссылке на их расположение — индексу.
</p>
Это отличный способ хранить данные. Большинство языков программирования позволяют так или иначе выделить память в виде массива и оперировать его содержимым. Последовательное хранение данных увеличивает производительность (data locality), позволяет легко итерироваться по содержимому и получать доступ к произвольному элементу по индексу.
Тем не менее, иногда массив — не самая подходящая структура.
<p>
  Разберем реализуацию массива:<br>
  Типовым способом реализации статического гомогенного (хранящего данные одного типа) массива является следующий :

    Под массив выделяется непрерывный блок памяти объёмом S*m1*m2*m3…mn,
     где S — размер одного элемента, а m1…mn — размеры диапазонов
      индексов (то есть количество значений, которые может принимать
       соответствующий индекс).<br>
    При обращении к элементу массива A[i1, i2, i3, …, in]
     адрес соответствующего элемента вычисляется
      как B+S*((…(i1p*m1+i2p)*m2+…+i(n-1)p)*mn-1+inp),
       где B — база (адрес начала блока памяти массива),
        ikp — значение k-го индекса, приведённое к целому
         с нулевым начальным смещением. Порядок следования
          индексов в формуле вычисления адреса может быть различным.
           Приведённый соответствует реализации в большинстве 
           компиляторов языка Си; в Фортране порядок индексов
            противоположен.
</p>

<p>То есть при объявлении массива сразу задается объем памяти, который нужно выделить
  Это значит, что для вставки нового элемента в уже заполненный массив
нужно выделить новую область памяти, скопировать старые значения в новый массив и добавить то значение, которое мы хотели вставить.
Выходит, что для вставки одного элемента, в определенный момент в памяти будет находиться два одинаковых массива. </p>
<p>
    Свя́зный спи́сок — базовая динамическая структура данных в информатике, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

</p>
<p> Для того, чтобы вставить новый элемент в связный список, нужно просто кинуть с последнего элемента списка ссылку на нужный элемент. То есть операции вставки занимает гораздо меньше времени чем в массиве, однако существует одна довольно важная операция в чем список проигрывает массиву.
   </p>
  <p>
    Элемент будет представляться структурой в которой мы будем хранить нужное значение, и ссылку на следующий элемент.
    <p class="fig"><img  src="Node.png" alt=""></p>
    Давайте напишем класс связного списка, сделаем метод вставки элемента и метод вывода данных в списке.
     <p class="fig"><img src="Linked_list.png" alt=""></p>
     <h3 id="Вставка элемента">Вставка элемента</h3>
     <p class="fig">Предположим, что у нас уже что-то лежит в списке и мы хотим вставить новый элемент:
     <div><img src="push1.png" alt=""></div>
     Для этого нужно в новом элементе кинуть ссылку на первый элемент списка<br>
     <b>Hint: Узел Head не является первым элементом, первый элемент тот, на который указывает Head</b>
     <div><img src="push2.png"alt=""></div>
     Затем нужно что Head указывал на ваш новый элемент
     <div><img src="push3.png"alt=""></div></p>

     <h3 id="Что нужно сделать">Что cделать?</h3>
     В этой работе вам нужно будет реализовать ряд методов к списку:
     <ul>
        <li>Метод, который возвращает длину списка</li>
        <li>Метод вставки элемента в конец списка</li>
        <li>Метод вставки элемента, после другого</li>
        <li>Метод удаления элемента</li>
        <li>Метод нахождения элемента значение которого, совпадает с нужным</li>
      </ul>
      Также я хочу чтобы вы покрыли код тестами
      <a href="https://github.com/TolMalware/githubpage/blob/master/Linked_list.h">шаблон кода</a>
      <a href="https://github.com/TolMalware/githubpage/blob/master/test.cpp">Пример теста</a>


<script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>