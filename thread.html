<link rel="stylesheet" href="main.css">
<style>
    .fig {
     text-align: center; /* Выравнивание по центру */ 
    }
   </style>
<div class = "wrapper">
    <div class="post-content" itemprop="articleBody">
<h3 id="Очередь">Очередь</h3>
<p>Очередь (англ. queue)  — это структура данных, добавление и удаление элементов в которой происходит путём операций push и pop соответственно. Притом первым из очереди удаляется элемент, который был помещен туда первым, то есть в очереди реализуется принцип «первым вошел — первым вышел» (англ. first-in, first-out — FIFO). У очереди имеется голова (англ. head) и хвост (англ. tail). Когда элемент ставится в очередь, он занимает место в её хвосте. Из очереди всегда выводится элемент, который находится в ее голове. Очередь поддерживает следующие операции:
    <ul style="float: left">
    <li>empty — проверка очереди на наличие в ней элементов,</li>
    <li>push (запись в очередь) — операция вставки нового элемента,</li>
    <li>pop (снятие с очереди) — операция удаления нового элемента,</li>
    <li>size — операция получения количества элементов в очереди.</li>
</ul>
<img src="thread/queue.png"  height="250" width="250" alt="">
</p>
<h3 id = "Стек"> Стек</h3>
<p>
        Стек (от англ. stack — стопка) — структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека. Притом первым из стека удаляется элемент, который был помещен туда последним, то есть в стеке реализуется стратегия «последним вошел — первым вышел» (last-in, first-out — LIFO). Примером стека в реальной жизни может являться стопка тарелок: когда мы хотим вытащить тарелку, мы должны снять все тарелки выше. Вернемся к описанию операций стека:
        <ul style="float: left">
                <li>empty — проверка стека на наличие в нем элементов,</li>
                <li>push (запись в стек) — операция вставки нового элемента,</li>
                <li>pop (снятие со стека) — операция удаления нового </li>элемента.
        </ul>
        <img src="thread/stack.png"  height="250" width="250" alt="">
</p>
<h3>Многопоточность</h3>
<p>
        Что такое многопоточность? В многоядерных процессорах или многопроцессорных системах многопоточность осуществляется тем что на разных ядрах или процессорах параллельно исполняются несколько процессов. А вот что касается одноядерного компьютера то мнгопоточность осуществляется путем разделения рабочего времени процессора между процессами. Операционная система по очереди дает на выполнения процессору некоторое количество инструкций от каждого процесса. Получается что в реальности процессы не выполняется одновременно, а только имитируется их одновременное выполнение. Это свойство операционной системы и называется многопоточностю. Многопоточность используется в тех случаях когда параллельное выполнение некоторых задач приводит к боле эффективному использованию ресурсов вычислительной системы. Надо отметить что в многопоточной приложении потоки выполняются в  адресном пространстве приложения.

        <div class="fig"><p>
                В новом стандарте C++11 многопоточность осуществлен в классе thread, который определен в файле thread.h. Для того чтобы создать новый поток нужно создать объект класса thread и инициализировать передав в конструктор имя функции которая должна выполнятся в потоке. Давайте посмотрим на маленький пример  многопоточной программы чтобы все стало понятнее.
        </p>
        <img class="fig" src="thread/simple_thread.png" alt="">
        <p>
            Треды это очень крутой инстумент, который позволяет вам выполнять ваш говнокод параллельно, например если вам нужно перемножать матрицы или перекочать пол тыртырнета. Однако используя треды крайне легко стрельнуть в ногу, например:
        </p>
        <img class="fig" src="thread/a++ example.png" alt="">
        <img class="fig" src="thread/a++ output.png" width="655" height="655" alt="">
        
    </div>
        
</p>
<h3>А кто это сделал?</h3>
<p>
        Планировщик – это часть менеджера процессов, которая ответственна за переключение между процессами и выбор очереди по какой-либо стратегии.

        ОС поддерживает все блоки управления процессом (PCB) в очередях планирования процесса:
        <ul>
            <li>Очередь задач (job queue) поддерживает все процессы в системе.</li>
            <li>Очередь ожидания (ready queue) хранит информацию обо всех процессах, находящихся в основной памяти в состоянии ожидания.</li> 
            <li>В эту очередь попадают и новые процессы.
            Очереди из устройств (device queue) – это процессы, заблокированные из-за недоступности устройств ввода-вывода.</li></ul>
            <img src="thread/plan.jpeg" alt="">
            ОС может использовать разные методы реализации для управления очередями (FIFO, Round Robin, Priority). Планировщик ОС определяет, когда и как перемещать процессы между готовыми и запущенными очередями (могут иметь только одну запись на ядро ​​процессора в системе). На приведенной выше диаграмме он был объединен с процессором.<br><br>

            Модели состояния делятся на активные и неактивные:
            
                <ul><li>Активные: при создании нового процесса он переходит в класс активных.</li>
                <li>Неактивные: процессы, которые не выполняются, а ждут завершения других процессов. Каждая запись в очереди является указателем на конкретный процесс. Очередь реализуется с использованием связанного списка. Использование диспетчера заключается в следующем: когда процесс прерывается, то переносится в очередь ожидания. Если процесс завершен или отменен – он отменяется вовсе.</li></ul>
            
            Переключение контекста – это механизм сохранения (в PCB) и восстановления контекста процессора с ранее запущенного промежутка времени. При использовании этого метода, коммутатор контекста позволяет использовать один процессор для нескольких действий одновременно. Кстати, контекстное переключение является неотъемлемой частью многозадачной операционной системы.
            
            Когда планировщик переключает процессор с одного процесса на другой, состояние из текущего запущенного процесса сохраняется в блоке управления. Затем состояние для следующего процесса загружается из своего PCB в регистры процессора. Только потом второй процесс может быть запущен.
            
            При переключении следующая информация сохраняется для последующего использования: счетчик программы, информация планировщика, значение регистра базы и лимита, используемый в настоящее время регистр, измененное состояние, информация о состоянии ввода и вывода, учетная информация.
        
